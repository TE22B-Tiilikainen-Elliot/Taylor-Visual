<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Taylor Polynomial Visualizer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            overflow: hidden;
            background: #000;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            cursor: pointer;
            touch-action: pan-y;
        }
        
        canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }
        
        .page-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100vh;
            transition: transform 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: transform;
        }
        
        #page1 {
            transform: translateX(0);
            z-index: 10;
        }
        
        #page2 {
            transform: translateX(100%);
            z-index: 9;
        }
        
        .page-container.slide-left {
            transform: translateX(-100%) !important;
        }
        
        .page-container.slide-right {
            transform: translateX(100%) !important;
        }
        
        .page-container.active {
            transform: translateX(0) !important;
            z-index: 10;
        }
        
        .nav-hint {
            position: fixed;
            bottom: 20px;
            right: 20px;
            color: rgba(255, 255, 255, 0.4);
            font-size: 14px;
            pointer-events: none;
            z-index: 1000;
        }
        
        .back-button {
            position: fixed;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 2px solid rgba(0, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 1000;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            text-decoration: none;
            color: #00ffff;
            font-size: 32px;
            font-weight: 300;
            line-height: 1;
            padding-bottom: 2px;
        }
        
        .back-button:hover {
            background: rgba(255, 255, 255, 0.1);
            border-color: #00ffff;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.3);
            transform: scale(1.1);
        }
        
        #info {
            position: fixed;
            top: 5%;
            left: 0;
            right: 0;
            width: 100%;
            color: #fff;
            pointer-events: none;
            padding: 0 2vw;
        }
        
        .polynomial-label {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            width: 100%;
            gap: min(20px, 2vw);
            font-size: clamp(14px, 2.5vw, 24px);
            font-weight: 600;
        }
        
        .function-label {
            font-weight: 700;
            font-size: clamp(16px, 3vw, 28px);
            text-shadow: 0 0 20px currentColor;
            transition: color 0.5s ease;
            text-align: right;
            padding-right: min(10px, 1vw);
            display: flex;
            align-items: center;
            justify-content: flex-end;
            white-space: nowrap;
        }
        
        .approx-symbol {
            font-size: clamp(20px, 3.5vw, 32px);
            font-weight: 400;
            text-align: center;
            flex-shrink: 0;
        }
        
        .polynomial-content {
            font-size: clamp(12px, 2vw, 20px);
            letter-spacing: 0px;
            text-shadow: 0 0 15px currentColor;
            text-align: left;
            padding-left: min(10px, 1vw);
            display: flex;
            align-items: center;
            word-spacing: 0px;
            overflow-x: auto;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            scrollbar-width: none;
        }
        
        .polynomial-content::-webkit-scrollbar {
            display: none;
        }
        
        .summation {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            font-size: 1.3em;
            margin-right: 6px;
            vertical-align: middle;
            position: relative;
            top: -2px;
        }
        
        .summation .sum-limits {
            font-size: 0.5em;
            line-height: 1;
        }
        
        .summation .sum-symbol {
            font-size: 1.8em;
            line-height: 0.8;
        }
        
        
        
        @keyframes termFadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }
        
        .fraction {
            display: inline-block;
            vertical-align: middle;
            text-align: center;
            font-size: 0.8em;
            margin: 0 2px;
        }
        
        .fraction .numerator {
            display: block;
            border-bottom: 1px solid currentColor;
            padding-bottom: 2px;
            line-height: 1.2;
        }
        
        .fraction .denominator {
            display: block;
            padding-top: 2px;
            line-height: 1.2;
        }
        
        /* Mobile optimizations */
        @media (max-width: 768px) {
            #info {
                top: 3%;
                padding: 0 4vw;
            }
            
            .polynomial-label {
                gap: 8px;
                grid-template-columns: minmax(60px, 1fr) auto minmax(100px, 2fr);
            }
            
            .function-label {
                font-size: clamp(18px, 4.5vw, 24px);
            }
            
            .polynomial-content {
                font-size: clamp(16px, 4vw, 20px);
                letter-spacing: 0.3px;
                word-spacing: 1px;
            }
            
            .fraction {
                font-size: 0.8em;
            }
        }
        
        /* Very small mobile */
        @media (max-width: 480px) {
            #info {
                top: 2%;
            }
            
            .polynomial-label {
                gap: 5px;
            }
            
            .function-label {
                padding-right: 5px;
            }
            
            .polynomial-content {
                padding-left: 5px;
            }
        }
        
        /* Landscape mobile */
        @media (max-height: 500px) and (orientation: landscape) {
            #info {
                top: 2%;
            }
            
            .polynomial-label {
                font-size: clamp(12px, 2vw, 18px);
            }
            
            .function-label {
                font-size: clamp(14px, 2.5vw, 20px);
            }
            
            .approx-symbol {
                font-size: clamp(16px, 2.5vw, 24px);
            }
        }
    </style>
</head>
<body>
    <a href="main.html" class="back-button" title="Back to main page">×</a>
    
    <div class="page-container active" id="page1">
        <canvas id="canvas"></canvas>
        <div id="info">
        <div class="polynomial-label">
            <div class="function-label" id="funcLabel">sin(x)</div>
            <span class="approx-symbol">≈</span>
            <div class="polynomial-content">
                <span class="summation">
                    <span class="sum-limits" id="sumUpper">∞</span>
                    <span class="sum-symbol">Σ</span>
                    <span class="sum-limits">n=<span id="sumLower">0</span></span>
                </span>
                <span id="polynomial">0</span>
            </div>
        </div>
        </div>
    </div>
    
    <div class="page-container" id="page2">
        <canvas id="canvas2"></canvas>
        <div id="info">
            <div class="polynomial-label">
                <div class="function-label" id="funcLabel2">Arc Length</div>
                <span class="approx-symbol">≈</span>
                <div class="polynomial-content">
                    <span id="arcLength">0</span>
                </div>
            </div>
        </div>
    </div>
    
    <div class="nav-hint">← → to navigate</div>
    
    <script>
        // Check URL parameters for initial page
        const urlParams = new URLSearchParams(window.location.search);
        const initialPage = parseInt(urlParams.get('page')) || 1;
        console.log('Initial page from URL:', initialPage);
        
        // Page navigation
        let currentPage = initialPage;
        const page1 = document.getElementById('page1');
        const page2 = document.getElementById('page2');
        
        function navigateToPage(pageNum) {
            if (pageNum === currentPage) return;
            
            console.log('Navigating to page', pageNum);
            currentPage = pageNum;
            
            if (pageNum === 1) {
                page1.classList.remove('slide-left');
                page1.classList.add('active');
                page2.classList.remove('active');
                page2.classList.add('slide-right');
            } else if (pageNum === 2) {
                page1.classList.remove('active');
                page1.classList.add('slide-left');
                page2.classList.remove('slide-right');
                page2.classList.add('active');
            }
        }
        
        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            console.log('Key pressed:', e.key);
            if (e.key === 'ArrowRight') {
                e.preventDefault();
                navigateToPage(2);
            } else if (e.key === 'ArrowLeft') {
                e.preventDefault();
                navigateToPage(1);
            }
        });
        
        // Touch/swipe navigation
        let touchStartX = 0;
        let touchEndX = 0;
        
        document.addEventListener('touchstart', (e) => {
            touchStartX = e.changedTouches[0].screenX;
        });
        
        document.addEventListener('touchend', (e) => {
            touchEndX = e.changedTouches[0].screenX;
            handleSwipe();
        });
        
        // Mouse swipe for PC
        let mouseDown = false;
        let mouseStartX = 0;
        let didSwipe = false;
        
        document.addEventListener('mousedown', (e) => {
            mouseDown = true;
            mouseStartX = e.clientX;
            didSwipe = false;
        });
        
        document.addEventListener('mousemove', (e) => {
            if (mouseDown) {
                const diff = Math.abs(e.clientX - mouseStartX);
                if (diff > 30) {
                    didSwipe = true;
                }
            }
        });
        
        document.addEventListener('mouseup', (e) => {
            if (mouseDown) {
                const mouseEndX = e.clientX;
                const diff = mouseStartX - mouseEndX;
                
                console.log('Mouse drag diff:', diff);
                
                if (Math.abs(diff) > 50) {
                    didSwipe = true;
                    if (diff > 0) {
                        console.log('Swiping right -> page 2');
                        navigateToPage(2);
                    } else {
                        console.log('Swiping left -> page 1');
                        navigateToPage(1);
                    }
                }
            }
            mouseDown = false;
        });
        
        function handleSwipe() {
            const diff = touchStartX - touchEndX;
            
            if (Math.abs(diff) > 50) {
                if (diff > 0) {
                    navigateToPage(2);
                } else {
                    navigateToPage(1);
                }
            }
        }
        
        // Page 1 (Taylor Polynomial)
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const funcLabel = document.getElementById('funcLabel');
        const polynomialDisplay = document.getElementById('polynomial');
        const sumLower = document.getElementById('sumLower');
        const sumUpper = document.getElementById('sumUpper');
        
        // Page 2 (Arc Length)
        const canvas2 = document.getElementById('canvas2');
        const ctx2 = canvas2.getContext('2d');
        const funcLabel2 = document.getElementById('funcLabel2');
        const arcLengthDisplay = document.getElementById('arcLength');
        
        // Canvas setup
        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            canvas2.width = window.innerWidth;
            canvas2.height = window.innerHeight;
        }
        resizeCanvas();
        window.addEventListener('resize', resizeCanvas);
        
        // Click to skip (only if not swiping)
        let clickStartX = 0;
        canvas.addEventListener('mousedown', (e) => {
            clickStartX = e.clientX;
        });
        
        canvas.addEventListener('click', (e) => {
            // Only trigger skip if it was a click, not a swipe
            if (Math.abs(e.clientX - clickStartX) < 10) {
                if (state.animationPhase !== 'fadingOut') {
                    state.animationPhase = 'fadingOut';
                    state.timer = 0;
                }
            }
        });
        
        // Color palette
        const colorPalette = [
            '#00ffff', // Cyan
            '#ff00ff', // Magenta
            '#00ff88', // Mint
            '#ff6b6b', // Coral
            '#4ecdc4', // Turquoise
            '#ffd93d', // Gold
            '#ff8ed4', // Pink
            '#8b5cf6', // Purple
            '#22d3ee', // Sky blue
            '#f97316'  // Orange
        ];
        
        // Animation state
        const state = {
            currentFunction: null,
            currentColor: '#00ffff',
            polynomialColor: '#ffff00',
            center: 0,
            terms: [],
            currentTermIndex: 0,
            animationPhase: 'fadingIn',
            fadeAlpha: 0,
            timer: 0,
            holdTimer: 0,
            maxTerms: 10,
            termBuildDuration: 1200, // ms to build each term (starting duration)
            baseBuildDuration: 1200,
            holdDuration: 1500, // ms to hold completed polynomial
            fadeDuration: 800, // ms for fade transitions
            xRangeMultiplier: 1,
            lastCompletedTermIndex: -1,
            currentSumIndex: 0,
            summationFadeStart: 0,
            summationFadeDuration: 1500
        };
        
        // Arc length state
        const arcState = {
            currentSegments: 1,
            maxSegments: 100,
            segmentBuildDuration: 150,
            baseBuildDuration: 150,
            animationPhase: 'fadingIn',
            timer: 0,
            holdTimer: 0,
            holdDuration: 1500,
            fadeDuration: 800,
            fadeAlpha: 0,
            lowerBound: -Math.PI,
            upperBound: Math.PI,
            targetSegments: 100
        };
        
        // Update summation notation display
        function updateSummationDisplay() {
            sumLower.textContent = state.currentSumIndex;
            const isInfiniteSeries = state.currentFunction && state.currentFunction.isInfinite;
            sumUpper.textContent = isInfiniteSeries ? '∞' : state.maxTerms - 1;
        }
        
        // Generate random polynomial function
        function generateRandomPolynomial() {
            const degree = 3 + Math.floor(Math.random() * 3) * 2; // 3, 5, or 7 (odd degrees)
            const coeffs = [];
            const xRange = 2 + Math.random() * 2;
            
            for (let i = 0; i <= degree; i++) {
                if (i === degree) {
                    // Leading coefficient (non-zero)
                    coeffs[i] = (Math.random() - 0.5) * 0.3;
                } else {
                    coeffs[i] = (Math.random() - 0.5) * 2;
                }
            }
            
            return {
                label: `P(x)`,
                compute: (x) => {
                    let sum = 0;
                    for (let i = 0; i <= degree; i++) {
                        sum += coeffs[i] * Math.pow(x, i);
                    }
                    return sum;
                },
                getCoefficient: (n) => {
                    return n <= degree ? coeffs[n] : 0;
                },
                maxTerms: degree + 1,
                xRangeMultiplier: xRange,
                isTrig: false,
                isInfinite: false
            };
        }
        
        // Function definitions with Taylor series coefficients
        const functionGenerators = [
            () => {
                const xMult = 2 + Math.random() * 2;
                return {
                    label: 'sin(x)',
                    compute: (x) => Math.sin(x),
                    getCoefficient: (n) => {
                        if (n % 2 === 0) return 0;
                        const sign = Math.pow(-1, (n - 1) / 2);
                        return sign / factorialMemo(n);
                    },
                    maxTerms: 100,
                    xRangeMultiplier: xMult,
                    isTrig: true,
                    isInfinite: true,
                    summationFormula: '<span class="fraction"><span class="numerator">(-1)<sup>n</sup>x<sup>2n+1</sup></span><span class="denominator">(2n+1)!</span></span>'
                };
            },
            () => {
                const xMult = 2 + Math.random() * 2;
                return {
                    label: 'cos(x)',
                    compute: (x) => Math.cos(x),
                    getCoefficient: (n) => {
                        if (n % 2 === 1) return 0;
                        const sign = Math.pow(-1, n / 2);
                        return sign / factorialMemo(n);
                    },
                    maxTerms: 100,
                    xRangeMultiplier: xMult,
                    isTrig: true,
                    isInfinite: true,
                    summationFormula: '<span class="fraction"><span class="numerator">(-1)<sup>n</sup>x<sup>2n</sup></span><span class="denominator">(2n)!</span></span>'
                };
            },
            () => ({
                label: 'e^x',
                compute: (x) => Math.exp(x),
                getCoefficient: (n) => {
                    return 1 / factorialMemo(n);
                },
                maxTerms: 80,
                xRangeMultiplier: 1,
                isTrig: false,
                isInfinite: true,
                summationFormula: '<span class="fraction"><span class="numerator">x<sup>n</sup></span><span class="denominator">n!</span></span>'
            }),
            () => {
                return {
                    label: 'arctan(x)',
                    compute: (x) => Math.atan(x),
                    getCoefficient: (n) => {
                        if (n % 2 === 0) return 0;
                        const sign = Math.pow(-1, (n - 1) / 2);
                        return sign / n;
                    },
                    maxTerms: 80,
                    xRangeMultiplier: 1,
                    isTrig: true,
                    isInfinite: true,
                    summationFormula: '<span class="fraction"><span class="numerator">(-1)<sup>n</sup>x<sup>2n+1</sup></span><span class="denominator">2n+1</span></span>'
                };
            },
            () => {
                return {
                    label: 'ln(1+x)',
                    compute: (x) => {
                        if (x <= -1) return NaN;
                        return Math.log(1 + x);
                    },
                    getCoefficient: (n) => {
                        if (n === 0) return 0;
                        const sign = Math.pow(-1, n + 1);
                        return sign / n;
                    },
                    maxTerms: 60,
                    xRangeMultiplier: 0.8,
                    isTrig: true,
                    isInfinite: true,
                    summationFormula: '<span class="fraction"><span class="numerator">(-1)<sup>n+1</sup>x<sup>n</sup></span><span class="denominator">n</span></span>'
                };
            },
            generateRandomPolynomial,
            generateRandomPolynomial
        ];
        
        // Memoized factorial
        const factorialCache = [1];
        function factorialMemo(n) {
            if (factorialCache[n] !== undefined) return factorialCache[n];
            let result = factorialCache[factorialCache.length - 1];
            for (let i = factorialCache.length; i <= n; i++) {
                result *= i;
                factorialCache[i] = result;
            }
            return factorialCache[n];
        }
        
        // Utility functions
        function lerp(a, b, t) {
            return a + (b - a) * t;
        }
        
        function smoothStep(t) {
            return t * t * (3 - 2 * t);
        }
        
        function easeInOut(t) {
            return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
        }
        
        // Coordinate transformation
        function worldToScreen(x, y) {
            const xRange = Math.PI * state.xRangeMultiplier;
            const yRange = 3;
            const sx = (x / xRange) * (canvas.width * 0.45) + canvas.width / 2;
            const sy = canvas.height / 2 - (y / yRange) * (canvas.height * 0.4);
            return { x: sx, y: sy };
        }
        
        function screenToWorld(sx, sy) {
            const x = ((sx - canvas.width / 2) / (canvas.width * 0.4)) * xRange;
            const y = ((canvas.height / 2 - sy) / (canvas.height * 0.35)) * yRange;
            return { x, y };
        }
        
        // Drawing functions
        function drawAxes() {
            ctx.strokeStyle = '#555';
            ctx.lineWidth = 1.5;
            
            const xRange = Math.PI * state.xRangeMultiplier;
            const y0 = worldToScreen(0, 0).y;
            const x0 = worldToScreen(0, 0).x;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, y0);
            ctx.lineTo(canvas.width, y0);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(x0, 0);
            ctx.lineTo(x0, canvas.height);
            ctx.stroke();
            
            // Draw tick marks
            ctx.strokeStyle = '#666';
            ctx.lineWidth = 1;
            const tickSize = 8;
            
            // X-axis ticks (every π/2 or similar)
            const xTickInterval = Math.PI / 2;
            for (let x = -xRange; x <= xRange; x += xTickInterval) {
                if (Math.abs(x) < 0.01) continue; // Skip origin
                const screen = worldToScreen(x, 0);
                ctx.beginPath();
                ctx.moveTo(screen.x, screen.y - tickSize / 2);
                ctx.lineTo(screen.x, screen.y + tickSize / 2);
                ctx.stroke();
            }
            
            // Y-axis ticks (every 1 unit)
            const yTickInterval = 1;
            for (let y = -3; y <= 3; y += yTickInterval) {
                if (Math.abs(y) < 0.01) continue; // Skip origin
                const screen = worldToScreen(0, y);
                ctx.beginPath();
                ctx.moveTo(screen.x - tickSize / 2, screen.y);
                ctx.lineTo(screen.x + tickSize / 2, screen.y);
                ctx.stroke();
            }
        }
        
        function drawFunction(func, color, alpha = 1) {
            const xRange = Math.PI * state.xRangeMultiplier;
            ctx.strokeStyle = color;
            ctx.globalAlpha = alpha;
            ctx.lineWidth = 3;
            ctx.beginPath();
            
            let started = false;
            const step = (2 * xRange) / (canvas.width * 2);
            
            for (let x = -xRange; x <= xRange; x += step) {
                const y = func(x);
                if (!isFinite(y) || Math.abs(y) > 100) continue;
                
                const screen = worldToScreen(x, y);
                
                if (!started) {
                    ctx.moveTo(screen.x, screen.y);
                    started = true;
                } else {
                    ctx.lineTo(screen.x, screen.y);
                }
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        // Draw error visualization (vertical bars)
        function drawErrorBars() {
            if (state.terms.length === 0 || state.animationPhase === 'fadingIn' || state.animationPhase === 'fadingOut') return;
            
            const xRange = Math.PI * state.xRangeMultiplier;
            const step = (2 * xRange) / 30; // Sample 30 points
            
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.08)';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5;
            
            for (let x = -xRange; x <= xRange; x += step) {
                const targetY = state.currentFunction.compute(x);
                const approxY = evaluateTaylorPolynomial(x, state.terms);
                
                if (!isFinite(targetY) || !isFinite(approxY)) continue;
                if (Math.abs(targetY) > 100 || Math.abs(approxY) > 100) continue;
                
                const screen1 = worldToScreen(x, targetY);
                const screen2 = worldToScreen(x, approxY);
                
                ctx.beginPath();
                ctx.moveTo(screen1.x, screen1.y);
                ctx.lineTo(screen2.x, screen2.y);
                ctx.stroke();
            }
            
            ctx.globalAlpha = 1;
        }
        
        function evaluateTaylorPolynomial(x, terms) {
            let sum = 0;
            for (let i = 0; i < terms.length; i++) {
                const term = terms[i];
                sum += term.coefficient * Math.pow(x, term.power);
            }
            return sum;
        }
        
        // Format polynomial for display with factorial notation as fractions
        function formatPolynomial(terms, lastCompletedIndex) {
            if (terms.length === 0) return '0';
            
            let result = '';
            let termCount = 0;
            const isTrigOrExp = state.currentFunction && state.currentFunction.isTrig;
            
            for (let i = 0; i < terms.length; i++) {
                const term = terms[i];
                if (Math.abs(term.coefficient) < 0.00001) continue;
                
                const power = term.power;
                
                // For trig/exp functions, format with factorials; for polynomials, use decimals
                let numerator, shouldUseFraction;
                if (isTrigOrExp) {
                    const factorial = factorialMemo(power);
                    numerator = Math.round(term.coefficient * factorial);
                    shouldUseFraction = (power > 0);
                } else {
                    numerator = term.coefficient;
                    shouldUseFraction = false;
                }
                
                if (Math.abs(numerator) < 0.00001) continue;
                
                // Check if this is the newly added term that should fade in
                const isNewTerm = (i === lastCompletedIndex);
                
                // Wrapper for the entire term including sign
                if (isNewTerm) {
                    result += '<span style="opacity: 0; animation: termFadeIn 0.5s ease-out forwards; display: inline-block;">';
                }
                
                // Sign
                if (termCount === 0) {
                    if (numerator < 0) result += '−';
                } else {
                    result += numerator > 0 ? ' + ' : ' − ';
                }
                
                const absNumerator = Math.abs(numerator);
                
                // Build the term
                if (power === 0) {
                    // Constant term - always show as simple number
                    if (isTrigOrExp) {
                        result += absNumerator;
                    } else {
                        result += absNumerator.toFixed(2);
                    }
                } else {
                    // All non-constant terms shown as fractions with n! denominator
                    let numPart = '';
                    
                    if (isTrigOrExp) {
                        // For trig/exp: coefficient is already factored out
                        if (absNumerator !== 1) {
                            numPart += absNumerator;
                        }
                    } else {
                        // For polynomials: show actual coefficient * n!
                        const factorial = factorialMemo(power);
                        const scaledCoeff = (absNumerator * factorial).toFixed(2);
                        numPart += scaledCoeff;
                    }
                    
                    // Add variable and power
                    if (power === 1) {
                        numPart += 'x';
                    } else {
                        numPart += `x<sup>${power}</sup>`;
                    }
                    
                    // Create fraction with n! denominator
                    result += `<span class="fraction"><span class="numerator">${numPart}</span><span class="denominator">${power}!</span></span>`;
                }
                
                if (isNewTerm) {
                    result += '</span>';
                }
                
                termCount++;
            }
            
            return result || '0';
        }
        
        // Initialize new function with random generation
        function initNewFunction() {
            // Pick a random function generator
            const generator = functionGenerators[Math.floor(Math.random() * functionGenerators.length)];
            const func = generator();
            
            // Pick two distinct random colors for this cycle
            const shuffled = [...colorPalette].sort(() => Math.random() - 0.5);
            state.currentColor = shuffled[0];
            state.polynomialColor = shuffled[1];
            
            state.currentFunction = func;
            state.terms = [];
            state.currentTermIndex = 0;
            state.timer = 0;
            state.holdTimer = 0;
            state.maxTerms = func.maxTerms;
            state.xRangeMultiplier = func.xRangeMultiplier || 1;
            state.lastCompletedTermIndex = -1;
            state.currentSumIndex = 0;
            state.termBuildDuration = state.baseBuildDuration;
            
            console.log(`New function: ${func.label}, maxTerms: ${func.maxTerms}`);
            console.log('Function object:', func);
            
            funcLabel.textContent = func.label;
            funcLabel.style.color = state.currentColor;
            polynomialDisplay.style.color = state.polynomialColor;
            polynomialDisplay.innerHTML = '0';
            updateSummationDisplay();
            
            // Initialize arc length state
            initArcLengthState();
        }
        
        function initArcLengthState() {
            const xRange = Math.PI * state.xRangeMultiplier;
            
            // Random bounds within the function's range
            const minX = -xRange;
            const maxX = xRange;
            const range = maxX - minX;
            
            // Generate random bounds (at least 30% of total range)
            const minRange = range * 0.3;
            const boundRange = minRange + Math.random() * (range - minRange);
            const startPos = minX + Math.random() * (range - boundRange);
            
            arcState.lowerBound = startPos;
            arcState.upperBound = startPos + boundRange;
            arcState.currentSegments = 1;
            arcState.maxSegments = 100;
            arcState.targetSegments = 1;
            arcState.animationPhase = 'fadingIn';
            arcState.timer = 0;
            arcState.holdTimer = 0;
            arcState.fadeAlpha = 0;
            arcState.segmentBuildDuration = arcState.baseBuildDuration;
            
            funcLabel2.textContent = `Arc Length of ${state.currentFunction.label}`;
            funcLabel2.style.color = state.currentColor;
            arcLengthDisplay.style.color = state.polynomialColor;
        }
        
        // Update polynomial display with fade-in effect
        function updatePolynomialDisplay(lastCompletedIndex = -1) {
            const html = formatPolynomial(state.terms, lastCompletedIndex);
            polynomialDisplay.innerHTML = html;
            
            // Check if content would wrap to multiple lines or after 15 terms
            const shouldShowSummation = state.currentTermIndex > 15 || 
                                        polynomialDisplay.scrollWidth > polynomialDisplay.clientWidth;
            
            if (shouldShowSummation && state.currentFunction && state.currentFunction.summationFormula) {
                polynomialDisplay.innerHTML = state.currentFunction.summationFormula;
            }
        }
        
        // Animation loop
        let lastTime = 0;
        
        function animate(currentTime) {
            const dt = currentTime - lastTime;
            lastTime = currentTime;
            
            // Clear canvas
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Update state based on phase
            if (state.animationPhase === 'fadingIn') {
                state.timer += dt;
                state.fadeAlpha = Math.min(1, state.timer / state.fadeDuration);
                
                if (state.fadeAlpha >= 1) {
                    state.animationPhase = 'building';
                    state.timer = 0;
                }
                
                drawAxes();
                if (state.currentFunction) {
                    drawFunction(state.currentFunction.compute, state.currentColor, state.fadeAlpha);
                }
                
            } else if (state.animationPhase === 'building') {
                // Add or update current term
                const targetCoeff = state.currentFunction.getCoefficient(state.currentTermIndex);
                
                // Skip zero terms instantly
                if (Math.abs(targetCoeff) < 0.00001) {
                    state.terms.push({
                        coefficient: 0,
                        power: state.currentTermIndex
                    });
                    state.currentTermIndex++;
                    state.timer = 0;
                    
                    // Still draw during zero term skip to prevent blink
                    drawAxes();
                    drawErrorBars();
                    drawFunction(state.currentFunction.compute, state.currentColor);
                    drawFunction(
                        (x) => evaluateTaylorPolynomial(x, state.terms),
                        state.polynomialColor
                    );
                    
                    // Check if all terms are complete
                    if (state.currentTermIndex >= state.maxTerms) {
                        state.animationPhase = 'holding';
                        state.holdTimer = 0;
                    }
                } else {
                    // Animate non-zero terms
                    state.timer += dt;
                    const progress = Math.min(1, state.timer / state.termBuildDuration);
                    const smoothProgress = smoothStep(progress);
                    
                    const currentCoeff = lerp(0, targetCoeff, smoothProgress);
                    
                    // Update terms array
                    if (state.terms.length === state.currentTermIndex) {
                        state.terms.push({
                            coefficient: currentCoeff,
                            power: state.currentTermIndex
                        });
                    } else {
                        state.terms[state.currentTermIndex].coefficient = currentCoeff;
                    }
                    
                    // Draw
                    drawAxes();
                    drawErrorBars();
                    drawFunction(state.currentFunction.compute, state.currentColor);
                    drawFunction(
                        (x) => evaluateTaylorPolynomial(x, state.terms),
                        state.polynomialColor
                    );
                    
                    // Update display during animation
                    updatePolynomialDisplay(-1);
                    
                    // Update sum index for non-zero terms
                    if (Math.abs(targetCoeff) > 0.00001) {
                        state.currentSumIndex = state.currentTermIndex;
                        updateSummationDisplay();
                    }
                    
                    // Check if term is complete
                    if (progress >= 1) {
                        state.lastCompletedTermIndex = state.currentTermIndex;
                        state.currentTermIndex++;
                        state.timer = 0;
                        
                        // Calculate exponential speed increase for NEXT term
                        const speedupStart = 4;
                        const speedupFactor = 0.92;
                        if (state.currentTermIndex > speedupStart) {
                            const termsAfterSpeedup = state.currentTermIndex - speedupStart;
                            state.termBuildDuration = state.baseBuildDuration * Math.pow(speedupFactor, termsAfterSpeedup);
                            state.termBuildDuration = Math.max(state.termBuildDuration, 100);
                        }
                        
                        // Debug logging
                        if (state.currentTermIndex % 10 === 0) {
                            console.log(`Term ${state.currentTermIndex}/${state.maxTerms}, duration: ${state.termBuildDuration.toFixed(0)}ms`);
                        }
                        
                        // Trigger display update with fade animation
                        setTimeout(() => {
                            updatePolynomialDisplay(state.lastCompletedTermIndex);
                        }, 10);
                        
                        // Update sum index
                        state.currentSumIndex = state.currentTermIndex;
                        updateSummationDisplay();
                        
                        // Check if all terms are complete
                        if (state.currentTermIndex >= state.maxTerms) {
                            state.animationPhase = 'holding';
                            state.holdTimer = 0;
                            updateSummationDisplay();
                        }
                    }
                }
                
            } else if (state.animationPhase === 'holding') {
                state.holdTimer += dt;
                
                drawAxes();
                drawErrorBars();
                drawFunction(state.currentFunction.compute, state.currentColor);
                drawFunction(
                    (x) => evaluateTaylorPolynomial(x, state.terms),
                    state.polynomialColor
                );
                
                if (state.holdTimer >= state.holdDuration) {
                    state.animationPhase = 'fadingOut';
                    state.timer = 0;
                }
                
            } else if (state.animationPhase === 'fadingOut') {
                state.timer += dt;
                state.fadeAlpha = Math.max(0, 1 - state.timer / state.fadeDuration);
                
                drawAxes();
                drawFunction(state.currentFunction.compute, state.currentColor, state.fadeAlpha);
                drawFunction(
                    (x) => evaluateTaylorPolynomial(x, state.terms),
                    state.polynomialColor,
                    state.fadeAlpha
                );
                
                if (state.fadeAlpha <= 0) {
                    initNewFunction();
                    state.animationPhase = 'fadingIn';
                    state.timer = 0;
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        // Click to skip on page 2
        canvas2.addEventListener('click', () => {
            if (arcState.animationPhase !== 'fadingOut') {
                arcState.animationPhase = 'fadingOut';
                arcState.timer = 0;
            }
        });
        
        // Arc length calculation (Page 2)
        function calculateArcLength(func, xStart, xEnd, segments) {
            let length = 0;
            const dx = (xEnd - xStart) / segments;
            
            for (let i = 0; i < segments; i++) {
                const x1 = xStart + i * dx;
                const x2 = x1 + dx;
                const y1 = func(x1);
                const y2 = func(x2);
                
                if (isFinite(y1) && isFinite(y2)) {
                    const segmentLength = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
                    length += segmentLength;
                }
            }
            
            return length;
        }
        
        // Draw arc length visualization
        function drawArcLengthVisualization(segments, fadeAlpha = 1) {
            if (!state.currentFunction) return;
            
            // Clear canvas
            ctx2.fillStyle = '#000';
            ctx2.fillRect(0, 0, canvas2.width, canvas2.height);
            
            // Draw axes
            const xRange = Math.PI * state.xRangeMultiplier;
            ctx2.strokeStyle = '#555';
            ctx2.lineWidth = 1.5;
            
            const y0 = worldToScreen(0, 0).y;
            const x0 = worldToScreen(0, 0).x;
            
            // X-axis
            ctx2.beginPath();
            ctx2.moveTo(0, y0);
            ctx2.lineTo(canvas2.width, y0);
            ctx2.stroke();
            
            // Y-axis
            ctx2.beginPath();
            ctx2.moveTo(x0, 0);
            ctx2.lineTo(x0, canvas2.height);
            ctx2.stroke();
            
            // Draw the full function curve
            ctx2.globalAlpha = fadeAlpha;
            ctx2.strokeStyle = state.currentColor;
            ctx2.lineWidth = 3;
            ctx2.beginPath();
            
            let started = false;
            const step = (2 * xRange) / (canvas2.width * 2);
            
            for (let x = -xRange; x <= xRange; x += step) {
                const y = state.currentFunction.compute(x);
                if (!isFinite(y) || Math.abs(y) > 100) continue;
                
                const screen = worldToScreen(x, y);
                
                if (!started) {
                    ctx2.moveTo(screen.x, screen.y);
                    started = true;
                } else {
                    ctx2.lineTo(screen.x, screen.y);
                }
            }
            
            ctx2.stroke();
            
            // Draw bounds markers
            ctx2.strokeStyle = `rgba(255, 100, 100, ${0.6 * fadeAlpha})`;
            ctx2.lineWidth = 2;
            ctx2.setLineDash([5, 5]);
            
            const lowerScreen = worldToScreen(arcState.lowerBound, 0);
            const upperScreen = worldToScreen(arcState.upperBound, 0);
            
            ctx2.beginPath();
            ctx2.moveTo(lowerScreen.x, 0);
            ctx2.lineTo(lowerScreen.x, canvas2.height);
            ctx2.stroke();
            
            ctx2.beginPath();
            ctx2.moveTo(upperScreen.x, 0);
            ctx2.lineTo(upperScreen.x, canvas2.height);
            ctx2.stroke();
            
            ctx2.setLineDash([]);
            
            // Draw line segments for approximation (only between bounds)
            const segmentStep = (arcState.upperBound - arcState.lowerBound) / segments;
            
            ctx2.strokeStyle = state.polynomialColor;
            ctx2.lineWidth = 2;
            
            for (let i = 0; i < segments; i++) {
                const x1 = arcState.lowerBound + i * segmentStep;
                const x2 = x1 + segmentStep;
                const y1 = state.currentFunction.compute(x1);
                const y2 = state.currentFunction.compute(x2);
                
                if (isFinite(y1) && isFinite(y2) && Math.abs(y1) < 100 && Math.abs(y2) < 100) {
                    const screen1 = worldToScreen(x1, y1);
                    const screen2 = worldToScreen(x2, y2);
                    
                    ctx2.beginPath();
                    ctx2.moveTo(screen1.x, screen1.y);
                    ctx2.lineTo(screen2.x, screen2.y);
                    ctx2.stroke();
                    
                    // Draw dots at endpoints
                    ctx2.fillStyle = state.polynomialColor;
                    ctx2.beginPath();
                    ctx2.arc(screen1.x, screen1.y, 3, 0, Math.PI * 2);
                    ctx2.fill();
                }
            }
            
            // Final point
            const finalY = state.currentFunction.compute(arcState.upperBound);
            if (isFinite(finalY) && Math.abs(finalY) < 100) {
                const finalScreen = worldToScreen(arcState.upperBound, finalY);
                ctx2.fillStyle = state.polynomialColor;
                ctx2.beginPath();
                ctx2.arc(finalScreen.x, finalScreen.y, 3, 0, Math.PI * 2);
                ctx2.fill();
            }
            
            ctx2.globalAlpha = 1;
            
            // Calculate and display arc length
            const arcLength = calculateArcLength(state.currentFunction.compute, arcState.lowerBound, arcState.upperBound, Math.floor(segments));
            arcLengthDisplay.textContent = `${arcLength.toFixed(4)} (n=${Math.floor(segments)})`;
        }
        
        // Animation loop for page 2
        let lastTime2 = 0;
        
        function animatePage2(currentTime) {
            const dt = currentTime - lastTime2;
            lastTime2 = currentTime;
            
            if (currentPage === 2 && state.currentFunction) {
                // Update arc length animation state
                if (arcState.animationPhase === 'fadingIn') {
                    arcState.timer += dt;
                    arcState.fadeAlpha = Math.min(1, arcState.timer / arcState.fadeDuration);
                    
                    if (arcState.fadeAlpha >= 1) {
                        arcState.animationPhase = 'building';
                        arcState.timer = 0;
                    }
                    
                    drawArcLengthVisualization(arcState.currentSegments, arcState.fadeAlpha);
                    
                } else if (arcState.animationPhase === 'building') {
                    arcState.timer += dt;
                    
                    // Gradually increase segments
                    const progress = Math.min(1, arcState.timer / arcState.segmentBuildDuration);
                    arcState.currentSegments = lerp(arcState.targetSegments, arcState.targetSegments + 1, smoothStep(progress));
                    
                    drawArcLengthVisualization(arcState.currentSegments, 1);
                    
                    if (progress >= 1) {
                        arcState.targetSegments++;
                        arcState.timer = 0;
                        
                        // Speed up after initial segments
                        if (arcState.targetSegments > 10) {
                            arcState.segmentBuildDuration = arcState.baseBuildDuration * 0.5;
                        }
                        if (arcState.targetSegments > 30) {
                            arcState.segmentBuildDuration = arcState.baseBuildDuration * 0.2;
                        }
                        
                        // Check if done
                        if (arcState.targetSegments >= arcState.maxSegments) {
                            arcState.animationPhase = 'holding';
                            arcState.holdTimer = 0;
                        }
                    }
                    
                } else if (arcState.animationPhase === 'holding') {
                    arcState.holdTimer += dt;
                    
                    drawArcLengthVisualization(arcState.currentSegments, 1);
                    
                    if (arcState.holdTimer >= arcState.holdDuration) {
                        arcState.animationPhase = 'fadingOut';
                        arcState.timer = 0;
                    }
                    
                } else if (arcState.animationPhase === 'fadingOut') {
                    arcState.timer += dt;
                    arcState.fadeAlpha = Math.max(0, 1 - arcState.timer / arcState.fadeDuration);
                    
                    drawArcLengthVisualization(arcState.currentSegments, arcState.fadeAlpha);
                    
                    if (arcState.fadeAlpha <= 0) {
                        // Trigger new function on page 1 which will also init arc state
                        initNewFunction();
                        arcState.animationPhase = 'fadingIn';
                        arcState.timer = 0;
                        
                        // Also reset page 1
                        state.animationPhase = 'fadingIn';
                        state.timer = 0;
                    }
                }
            }
            
            requestAnimationFrame(animatePage2);
        }
        
        // Start animation
        initNewFunction();
        
        // Set up initial page state if page 2 is requested
        if (initialPage === 2) {
            // Immediately set the correct classes without animation
            page1.classList.remove('active');
            page1.classList.add('slide-left');
            page2.classList.remove('slide-right');
            page2.classList.add('active');
        }
        
        requestAnimationFrame(animate);
        requestAnimationFrame(animatePage2);
    </script>
</body>
</html>
